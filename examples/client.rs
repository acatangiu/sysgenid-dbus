// This code was autogenerated with `dbus-codegen-rust -d com.RFC.sysgenid -p / -m None`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::blocking;

pub trait ComRFCSysgenid {
    fn count_outdated_watchers(&self) -> Result<u32, dbus::Error>;
    fn get_gen_counter(&self) -> Result<u32, dbus::Error>;
    fn trigger_gen_update(&self, min_gen: u32) -> Result<(), dbus::Error>;
    fn update_watcher(&self, tracking_flag: bool, watcher_counter: u32)
        -> Result<u32, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>> ComRFCSysgenid
    for blocking::Proxy<'a, C>
{
    fn count_outdated_watchers(&self) -> Result<u32, dbus::Error> {
        self.method_call("com.RFC.sysgenid", "CountOutdatedWatchers", ())
            .and_then(|r: (u32,)| Ok(r.0))
    }

    fn get_gen_counter(&self) -> Result<u32, dbus::Error> {
        self.method_call("com.RFC.sysgenid", "GetSysGenCounter", ())
            .and_then(|r: (u32,)| Ok(r.0))
    }

    fn trigger_gen_update(&self, min_gen: u32) -> Result<(), dbus::Error> {
        self.method_call("com.RFC.sysgenid", "TriggerSysGenUpdate", (min_gen,))
    }

    fn update_watcher(
        &self,
        tracking_flag: bool,
        watcher_counter: u32,
    ) -> Result<u32, dbus::Error> {
        self.method_call(
            "com.RFC.sysgenid",
            "UpdateWatcher",
            (tracking_flag, watcher_counter),
        )
        .and_then(|r: (u32,)| Ok(r.0))
    }
}

#[derive(Debug)]
pub struct ComRFCSysgenidNewGeneration {
    pub gen_counter: u32,
}

impl arg::AppendAll for ComRFCSysgenidNewGeneration {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.gen_counter, i);
    }
}

impl arg::ReadAll for ComRFCSysgenidNewGeneration {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ComRFCSysgenidNewGeneration {
            gen_counter: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ComRFCSysgenidNewGeneration {
    const NAME: &'static str = "NewGeneration";
    const INTERFACE: &'static str = "com.RFC.sysgenid";
}

#[derive(Debug)]
pub struct ComRFCSysgenidSystemReady {}

impl arg::AppendAll for ComRFCSysgenidSystemReady {
    fn append(&self, _: &mut arg::IterAppend) {}
}

impl arg::ReadAll for ComRFCSysgenidSystemReady {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ComRFCSysgenidSystemReady {})
    }
}

impl dbus::message::SignalArgs for ComRFCSysgenidSystemReady {
    const NAME: &'static str = "SystemReady";
    const INTERFACE: &'static str = "com.RFC.sysgenid";
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&self) -> Result<String, dbus::Error>;
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target = T>>
    OrgFreedesktopDBusIntrospectable for blocking::Proxy<'a, C>
{
    fn introspect(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.DBus.Introspectable", "Introspect", ())
            .and_then(|r: (String,)| Ok(r.0))
    }
}

// Autogenerated code ends here.

use dbus::blocking::Connection;
use dbus::Message;
use std::error::Error;
use std::time::Duration;

const SYSGENID_INTERFACE: &str = "com.RFC.sysgenid";
const SYGENID_PATH: &str = "/com/RFC/sysgenid";

fn main() -> Result<(), Box<dyn Error>> {
    // Let's start by starting up a connection to the session bus.
    let c = Connection::new_session()?;

    {
        let proxy = c.with_proxy(
            SYSGENID_INTERFACE,
            SYGENID_PATH,
            Duration::from_millis(5000),
        );

        // Let's start listening to signals.
        let _id1 = proxy.match_signal(
            |h: ComRFCSysgenidNewGeneration, _: &Connection, _: &Message| {
                println!("got NewGeneration signal! counter: {}", h.gen_counter);
                true
            },
        );
        let _id2 = proxy.match_signal(
            |_h: ComRFCSysgenidSystemReady, _: &Connection, _: &Message| {
                println!("got SystemReady signal!");
                true
            },
        );

        let (counter,): (u32,) = proxy.method_call(SYSGENID_INTERFACE, "GetSysGenCounter", ())?;
        println!("get counter (method): {}", counter);

        // Say hello to the server example, so we get a signal.
        let (counter,): (u32,) =
            proxy.method_call(SYSGENID_INTERFACE, "UpdateWatcher", (true, counter))?;
        println!("update self as tracked watcher; gen counter: {}", counter);

        println!("trigger new generation");
        proxy.method_call(SYSGENID_INTERFACE, "TriggerSysGenUpdate", (0 as u32,))?;

        let (counter,): (u32,) = proxy.method_call(SYSGENID_INTERFACE, "GetSysGenCounter", ())?;
        println!("get counter (method): {}", counter);

        let (counter,): (u32,) =
            proxy.method_call(SYSGENID_INTERFACE, "CountOutdatedWatchers", ())?;
        println!("outdated watchers (method): {}", counter);

        println!("removing self as tracked watcher");
        proxy.method_call(SYSGENID_INTERFACE, "UpdateWatcher", (false, counter))?;
    }

    // Listen to incoming signals forever.
    loop {
        c.process(Duration::from_millis(1000))?;
    }
}
